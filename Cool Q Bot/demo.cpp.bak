#define _CRT_SECURE_NO_WARNINGS
#include "cqsdk/cqsdk.h"
#include "autoSignInPlugin.h"

// namespace cq::app 包含插件本身的生命周期事件和管理
// namespace cq::event 用于注册 QQ 相关的事件处理函数
// namespace cq::api 用于调用酷 Q 提供的接口
// namespace cq::logging 用于日志
// namespace cq::message 提供封装了的 Message 等类

unsigned int cq::fileio::userDatas::totalGroupCounts = 0;
cq::fileio::userDatas groupDatas[64];
// 插件入口，在静态成员初始化之后，app::on_initialize 事件发生之前被执行，用于配置 SDK 和注册事件回调
CQ_MAIN
{
	cq::app::on_coolq_start = []
	{
		cq::logging::debug(u8"START", u8"Cool Q is starting!");

		cq::fileio::userDatas* groupDatasPtr;
		groupDatasPtr = groupDatas;
		cq::fileio::loadUserDataStream(groupDatasPtr);
	};
    cq::app::on_enable = []
	{
		long long startRuntime = GetTickCount();
        // cq::logging、cq::api、cq::dir 等命名空间下的函数只能在事件回调函数内部调用，而不能直接在 CQ_MAIN 中调用
		cq::logging::debug(u8"ENABLE", u8"Auto_Sign_In_Plugin is enabled!");

		try
		{
			std::string userDataMessage = "";
			std::cout << "Total Group Counts: " << cq::fileio::userDatas::readTotalGroupCounts() << std::endl;
			for (int i = 0; i < cq::fileio::userDatas::readTotalGroupCounts(); i++)
			{
				/// std::cout << "groupNumber: " << groupDatas[i].readGroupNumber() << std::endl;
				userDataMessage += "群号: " + groupDatas[i].readGroupNumber() + "\n";
				for (int j = 0; j < groupDatas[i].readTotalUserCounts(); j++)
				{
					/// std::cout << "userQQ: " << groupDatas[i].readUserQQs(j) << std::endl;
					/// std::cout << "userAccount: " << groupDatas[i].readUserAccounts(j) << std::endl;
					/// std::cout << "userPassword: " << groupDatas[i].readUserPasswords(j) << std::endl;
					/// std::cout << "userXAuthToken: " << groupDatas[i].readUserXAuthTokens(j) << std::endl << std::endl;
					userDataMessage += "    用户QQ: " + groupDatas[i].readUserQQs(j) + "\n";
					userDataMessage += "    用户账号: " + groupDatas[i].readUserAccounts(j) + "\n";
					userDataMessage += "    用户密码: " + groupDatas[i].readUserPasswords(j) + "\n";
					userDataMessage += "    用户Token: " + groupDatas[i].readUserXAuthTokens(j) + "\n\n";
				}
			}
			long long endRuntime = GetTickCount();
			cq::api::send_private_msg(1135989508, userDataMessage + "执行耗时：" + std::to_string(endRuntime - startRuntime) + "ms");
			cq::api::send_group_msg(628669530, "自动签到插件正在运行\n执行耗时：" + std::to_string(endRuntime - startRuntime) + "ms");
		}
		catch (const cq::exception::ApiError &err)
		{
            // API 调用失败
            cq::logging::debug(u8"API", u8"调用失败，错误码：" + std::to_string(err.code));
        }
    };

    cq::event::on_private_msg = [](const cq::PrivateMessageEvent &e)
	{
        cq::logging::debug(u8"消息", u8"收到私聊消息：" + e.message + u8"，发送者：" + std::to_string(e.user_id));

        //if (e.user_id != 1135989508) return;

        try {
            cq::api::send_private_msg(e.user_id, e.message); // echo 回去

            cq::api::send_msg(e.target, e.message); // 使用 e.target 指定发送目标

            // MessageSegment 类提供一些静态成员函数以快速构造消息段
            cq::Message msg = cq::MessageSegment::contact(cq::MessageSegment::ContactType::GROUP, 628669530);
            msg.send(e.target); // 使用 Message 类的 send 成员函数
        } catch (const cq::exception::ApiError &err)
		{
            // API 调用失败
            cq::logging::debug(u8"API", u8"调用失败，错误码：" + std::to_string(err.code));
        }

        e.block(); // 阻止事件继续传递给其它插件
    };

    cq::event::on_group_msg = [](const auto &e /* 使用 C++ 的 auto 关键字 */)
	{
		long long startRuntime = GetTickCount();
		using namespace std;
		//int position;
		//正则匹配
    	regex regexSignInAttempt("#code=(\\d{4})&amp;token=(\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12})");
		regex regexLoginAttempt("#account=(\\d{11})&amp;password=(\\S{6,20})");
		regex regexRebootAttempt("#reboot");
		regex regexPing("#ping");
		smatch result;

		if(regex_match(e.raw_message,result,regexPing))
		{
			cq::Message msg = u8"Pong!";
			long long endRuntime = GetTickCount();
			msg += u8"\n执行耗时：" + std::to_string(endRuntime - startRuntime) + "ms";
			cq::message::send(e.target, msg);
		}
		if((regex_match(e.raw_message,result,regexRebootAttempt))&&(e.user_id == 1135989508))
		{
			cq::Message msg = u8"正在执行REBOOT指令，10秒内重启……";
			long long endRuntime = GetTickCount();
			msg += u8"\n执行耗时：" + std::to_string(endRuntime - startRuntime) + "ms";
			cq::message::send(e.target, msg);
			system("taskkill /f /t /im CQP.exe");
		}
		if(regex_match(e.raw_message,result,regexLoginAttempt))
		{
			string yibanUsername = result[1], yibanPassword = result[2], xAuthToken;
			try
			{
				xAuthToken = cq::httpRequest::totalXAuthToken(yibanUsername, yibanPassword);
			}
			catch(std::string errorString)
			{
				xAuthToken = u8"错误提示：" + errorString;
			}
        	catch(unsigned int statusCode)
			{
            	xAuthToken = u8"错误码：" + to_string(statusCode);
        	}
			cq::Message msg = u8"登录测试:";
			msg += u8"\n用户QQ：" + std::to_string(e.user_id);
			msg += u8"\n易班账号：" + yibanUsername; // Message 类可以进行加法运算
            msg += u8"\n易班密码：" + yibanPassword; // Message 类可以进行加法运算
			msg += u8"\n返回：" + xAuthToken; // Message 类可以进行加法运算
			long long endRuntime = GetTickCount();
			msg += u8"\n执行耗时：" + std::to_string(endRuntime - startRuntime) + "ms";
			
			cq::message::send(e.target, msg);
		}
		if(regex_match(e.raw_message,result,regexSignInAttempt))
		{
			//smatch::iterator x;
			string signInCode, xAuthToken, statusCode;
			cq::Message msg = u8"签到测试"; // string 到 Message 自动转换
			signInCode = result[1];
			msg += u8"\n签到码：" + signInCode; // Message 类可以进行加法运算
			xAuthToken = result[2];
            msg += u8"\nX-Auth-Token：" + xAuthToken; // Message 类可以进行加法运算
			try
			{
				statusCode = cq::httpRequest::totalValidationCode(signInCode, xAuthToken);
			}
			catch(std::string errorString)
			{
				xAuthToken = u8"错误提示：" + errorString;
			}
        	catch(unsigned int statusCode)
			{
            	xAuthToken = u8"错误码：" + to_string(statusCode);
        	}
			msg += u8"\n返回：" + statusCode; // Message 类可以进行加法运算
			long long endRuntime = GetTickCount();
			msg += u8"\n执行耗时：" + std::to_string(endRuntime - startRuntime) + "ms";
			
            cq::message::send(e.target, msg); // 使用 message 命名空间的 send 函数
			
		}
        //const auto memlist = cq::api::get_group_member_list(e.group_id); // 获取数据接口
        //cq::Message msg = u8"检测到精确消息，RawMessage="; // string 到 Message 自动转换
        //msg += std::to_string(memlist.size()) + u8" 个成员"; // Message 类可以进行加法运算
        //msg += e.raw_message; // Message 类可以进行加法运算
        //cq::message::send(e.target, msg); // 使用 message 命名空间的 send 函数
    };
	cq::app::on_coolq_exit = []
	{
		cq::logging::debug(u8"Exit", u8"Cool Q Exited!");
	};
}


// 添加菜单项，需要同时在 <appid>.json 文件的 menu 字段添加相应的条目，function 字段为 menu_demo_1
CQ_MENU(menu_management)
{
    cq::logging::info(u8"菜单", u8"点击了示例菜单1");
    try
	{
        cq::api::send_private_msg(1135989508, "hello");
    }
	catch (const cq::exception::ApiError &)
	{
        cq::logging::warning(u8"菜单", u8"发送失败");
    }
}

// 不像 CQ_MAIN，CQ_MENU 可以多次调用来添加多个菜单
CQ_MENU(menu_settings)
{
    cq::logging::info(u8"菜单", u8"点击了示例菜单2");
    MessageBoxW(nullptr, L"这是一个提示", L"提示", MB_OK | MB_SETFOREGROUND | MB_TASKMODAL | MB_TOPMOST);
}